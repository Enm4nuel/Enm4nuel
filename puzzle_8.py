# -*- coding: utf-8 -*-
"""Proyecto_Puzzle_8_(Código_Esqueleto).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMa-DIC_N4j969sFA7x1NJbkzXeGv4lO

# Proyecto Puzzle-8

**Código esqueleto para el proyecto *Puzzle-8*** del Prof. Carlos Ogando para la asignatura Introducción a la IA en ITLA

**Integrantes del equipo:**
 
* Priscila Polanco -- 2020-10331 -- 202010331@itla.edu.do
* Enmanuelle Martinez -- 2018-5980 -- 20185980@itla.edu.do
* Cesar Mendez -- 2019-8384 -- 20198384@itla.edu.do
* Eduardo A. Sanchez -- 202010246 -- 202010246@itla.edu.do
* Gabriel de Jesus Hernandez -- 202010516 -- 202010516@itla.edu.do
* Nasser Emil Issa Tavares -- 20198015 -- 20198015@itla.edu.do
"""

"""
Código esqueleto para el proyecto Puzzle-8 del Prof. Carlos Ogando
para la asignatura Introducción a la IA en ITLA.
Python 3
"""

# Librerías

import queue as Q

import time

import resource

import math

from collections import deque

import heapq

# Clase que representa el Puzzle-n general

class PuzzleState(object):

    """docstring para PuzzleState"""

    def __init__(self, config, n, parent=None, action="Initial", cost=0):

        if n*n != len(config) or n < 2:

            raise Exception("the length of config is not correct!")

        self.n = n

        self.cost = cost

        self.parent = parent

        self.action = action

        self.dimension = n

        #Config
        self.config = config

        self.children = []


        for i, item in enumerate(self.config):

            if item == 0:

                self.blank_row = i // self.n

                self.blank_col = i % self.n

                break

    def display(self):

        for i in range(self.n):

            line = []

            offset = i * self.n

            for j in range(self.n):

                line.append(self.config[offset + j])

            print(line)

    def move_left(self):

        if self.blank_col == 0:

            return None

        else:

            blank_index = self.blank_row * self.n + self.blank_col

            target = blank_index - 1

            new_config = list(self.config)

            new_config[blank_index], new_config[target] = new_config[target], new_config[blank_index]

            return PuzzleState(tuple(new_config), self.n, parent=self, action="Left", cost=self.cost + 1)

    def move_right(self):

        if self.blank_col == self.n - 1:

            return None

        else:

            blank_index = self.blank_row * self.n + self.blank_col

            target = blank_index + 1

            new_config = list(self.config)

            new_config[blank_index], new_config[target] = new_config[target], new_config[blank_index]

            return PuzzleState(tuple(new_config), self.n, parent=self, action="Right", cost=self.cost + 1)

    def move_up(self):

        if self.blank_row == 0:

            return None

        else:

            blank_index = self.blank_row * self.n + self.blank_col

            target = blank_index - self.n

            new_config = list(self.config)

            new_config[blank_index], new_config[target] = new_config[target], new_config[blank_index]

            return PuzzleState(tuple(new_config), self.n, parent=self, action="Up", cost=self.cost + 1)

    def move_down(self):

        if self.blank_row == self.n - 1:

            return None

        else:

            blank_index = self.blank_row * self.n + self.blank_col

            target = blank_index + self.n

            new_config = list(self.config)

            new_config[blank_index], new_config[target] = new_config[target], new_config[blank_index]

            return PuzzleState(tuple(new_config), self.n,  parent=self, action="Down", cost=self.cost + 1)

    def expand(self):

        """Expandir el nodo"""

        # Añadir nodos hijos en orden UDLR (Up-Down-Left-Right)

        if len(self.children) == 0:

            up_child = self.move_up()

            if up_child is not None:

                self.children.append(up_child)

            down_child = self.move_down()

            if down_child is not None:

                self.children.append(down_child)

            left_child = self.move_left()

            if left_child is not None:

                self.children.append(left_child)

            right_child = self.move_right()

            if right_child is not None:

                self.children.append(right_child)

        return self.children

def writeOutput(state, nodes_expanded, max_search_depth, running_time):

    """
    Función que escribe output.txt
    (Los estudiantes deben cambiar el método para que opere con los parametros necesarios).
    """

    ### SU CÓDIGO VA AQUÍ ###

##Aqui primero crearemos una lista global partiendo de path_to_goal como parametro y siguiendo los demas algoritmos##
    path_to_goal = []
    cost_of_path = state.cost
    search_depth = cost_of_path
    while (state.action != "Initial"):
      path_to_goal.append(state.action)
      state = state.parent

    path_to_goal = path_to_goal[::-1] ##Luego se instanciara desde dos espacios antes para iniciar desde el arreglo -1 y dara los resultados de estadisticos como listado##
    result=["path_to_goal: ", "cost_of_path: ", "nodes_expanded: ", "search_depth:", "max_search_depth: "]

    print(f"""\n\n    
      path_to_goal: {str(path_to_goal)},
      cost_of_path: {str(cost_of_path)},
      nodes_expanded: {str(nodes_expanded)},
      search_depth: {str(search_depth)},
      max_search_depth: {str(max_search_depth)}
    """)
                                        ##Por ultimo se imprimira el archivo en funcion de cada resultado estadistico tomando su parametro raiz para que asi cada algoritmo se ejecute correctamente##
    f = open("output.txt", "w")
    f.write(result[0] + str(path_to_goal)+"\n")  ## En cada uno se toma su parametro inicial como se ve arriba##
    f.write(result[1]+ str(cost_of_path)+"\n")
    f.write(result[2] + str(nodes_expanded)+"\n")
    f.write(result[3]+ str(search_depth)+"\n")
    f.write(result[4] + str(max_search_depth)+"\n")
    f.write("running_time: %.8f" %running_time + "\n")
    f.write("max_ram_usage:%.8f"%float(resource.getrusage(resource.RUSAGE_SELF).ru_maxrss/1023E3))
    f.close()

    print("Se ha creado el archivo 'output.txt' con exito \n")

def bfs_search(initial_state):

    """BFS search"""

    ### SU CÓDIGO VA AQUÍ ###

    "Declaramos la frontera"
    frontier = deque()
    frontier.append(initial_state)

    "Declaramos los nodos que ya han explorados"
    explored = set()

    "Declaramos la profundidad máxima del árbol de búsqueda durante la vida útil del algoritmo"
    max_search_depth = 0

    "Declaramos el número de nodos que se han expandido"
    nodes_expanded = 0

    start_time = time.time()
 
    "Aquí empieza el ciclo de vida de búsqueda del algoritmo"
    while frontier:
      state = frontier.popleft() #El popleft es un método del deque que remueve o saca a un elemento de la izquierda del mismo y retorna un valor
      explored.add(state)

      if test_goal(state): #Aquí está el condicional donde se evalúa si se llego al estado objetivo
       end_time = time.time()
       running_time = end_time - start_time
       writeOutput(state, nodes_expanded, max_search_depth, running_time) #Parámetros que deben ser definidos en la función de arriba (writeOutput)
       return True

      "Si el resultado de la verificación es negativo, es decir, que no hemos llegado a nuestro objetivo, se expande el nodo"
      nodes_expanded = nodes_expanded + 1 
      nodos_vecinos = state.expand() #Función para expandir el nodo

      "Acá empezamos un forloop"
      for vecino in nodos_vecinos:
        if vecino.config not in explored: #Si tenemos nodos vecinos que NO han sido explorados
          if vecino not in frontier: #Nodos vecinos que NO estén en la frontera
            max_search_depth = max(vecino.cost, max_search_depth) #Me devolverá el max valor, es decir la profundidad maxima del arbol de busqueda, por eso le paso el cost, que sería el costo, la distancia
            frontier.append(vecino)
            explored.add(vecino.config) #Se agregan los nuevos nodos(los vecinos) a los explorados
    return False

def dfs_search(initial_state):

    """DFS search"""
    
    ### SU CÓDIGO VA AQUÍ ###  
    
    "Declaramos la frontera"
    frontier = [initial_state]
    frontier_dic = {} # almacena un valor (el nodo) y me recupera el valor  
    frontier_dic[tuple(initial_state.config)] = "add" 

    explored = set() #Declaramos los nodos que ya han explorados"
    
    #Declaramos el número de nodos que se han expandido
    nodes_expanded = 0

    max_search_depth = 0 

    start_time = time.time()

    while frontier:  
        state = frontier.pop() # este metodo pop me ayuda a retirar y retornar el ultimo elemento de una lista de nodos
        explored.add(state.config) 

        if test_goal(state): 
            path_to_goal = calculate_total_cost(state) # tenemos la secuencia de movimientos que se realizo para llegar a la meta con la distancia
            search_depth = len(path_to_goal) #La función len() devuelve los nodos que se encuentran en la tupla:
            end_time = time.time()
            running_time = end_time - start_time
            writeOutput(state, nodes_expanded, max_search_depth, running_time) #Parámetros que deben ser definidos en la función de arriba (writeOutput)
        
        "En caso de que no se encuentre resultados , se expande el nodo  "

        nodes_expanded = nodes_expanded + 1
        nodos_vecinos = state.expand()[::-1] # se expanden los nodos y obtenemos los elementos (nodos necesarios) menos el ultimo.
        
        for vecino in nodos_vecinos:
          if tuple(vecino.config) not in frontier_dic:  #Nodos vecinos que NO estén en la frontera
            if vecino.config not in explored: #Si tenemos nodos vecinos que NO han sido explorados
              max_search_depth = max(vecino.cost, max_search_depth)
              frontier_dic[tuple(vecino.config)] = "add"
              frontier.append(vecino)  #Se agregan los nuevos nodos(los vecinos) a la frontera
                 
    return False

def A_star_search(initial_state):

    """A * search"""

    ### SU CÓDIGO VA AQUÍ ###
    frontier = []
    explored = set()
    explored.add(initial_state.config)
    heapq.heappush(frontier, (0, time.time(), initial_state)) 
    nodes_expanded = 0
    max_search_depth = 0
    start_time = time.time()


    while frontier:
      state = heapq.heappop(frontier)
      plt = state[2]
      max_search_depth = max(plt.cost, max_search_depth)

      if test_goal(plt): #Aquí está el condicional donde se evalúa si se llego al estado objetivo
        end_time = time.time()
        running_time = end_time - start_time
        writeOutput(plt, nodes_expanded, max_search_depth, running_time) #Parámetros que deben ser definidos en la función de arriba (writeOutput)
        return True
    
      nodes_expanded = nodes_expanded + 1
      nodos_vecinos = plt.expand()

      for vecino in nodos_vecinos:
        if vecino.config not in explored:
          if vecino not in frontier:
            distancia = calculate_total_cost(vecino)
            heapq.heappush(frontier, (time.time(), distancia, vecino))
            explored.add(vecino.config)
    return False

def calculate_total_cost(state):

    """
    Calcula el costo total estimado de un estado
    Esto es la suma de las distancias Manhattan con respecto a otras celdas
    """
    ### SU CÓDIGO VA AQUÍ ###
    path_to_goal = []
    actual_node = state

    "Evaluamos si el costo del nodo actual es mayor a 1, de ser asi procedemos a realizar el calculo"
    "Caso contrario no se evalua nada, lo que indica o nos da a entender que el nodo actual no puede expandirse"
    while actual_node.cost >= 1:
        path_to_goal.insert(0, actual_node.action)
        actual_node = actual_node.parent

    return path_to_goal

def calculate_manhattan_dist(idx, value, n):

    """Calcula la distancia Manhattan de una celda"""

    ### SU CÓDIGO VA AQUÍ ###

    "La distancia Manhattan es la suma de las distancias desde la posición actual de cada ficha hasta su posición original."
    disX=  (idx%3) - (value%n)
    disY= (idx//3) - (value//3)
    distanciaManhattan = abs(disX) + abs(disY)
    return distanciaManhattan

def test_goal(puzzle_state):

  #Definimos una variable que sera igual a los valores actuales del puzzle
  state_config = puzzle_state.config

  #Creamos una condicion que retorne dos opciones diciendo que si el puzzle tiene los valores 
  if tuple(sorted(state_config)) == state_config:
    return True
  return False

# Función Main que leerá las entradas y llamará el algoritmo correspondiente

def main():

    query = input().split(" ")

    sm = query[0].lower()

    begin_state = query[1].split(",")

    begin_state = tuple(map(int, begin_state))

    size = int(math.sqrt(len(begin_state)))

    hard_state = PuzzleState(begin_state, size)

    if sm == "bfs":

        bfs_search(hard_state)

    elif sm == "dfs":

        dfs_search(hard_state)

    elif sm == "ast":

        A_star_search(hard_state)

    else:

        print("Introduzca comandos de argumentos válidos !")

if __name__ == '__main__':

    main()